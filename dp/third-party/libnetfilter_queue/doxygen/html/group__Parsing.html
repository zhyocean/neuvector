<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libnetfilter_queue: Message parsing functions [DEPRECATED]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libnetfilter_queue
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message parsing functions [DEPRECATED]</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2498927473326e81b6eea5b6a9d33b6e"><td class="memItemLeft" align="right" valign="top">struct nfqnl_msg_packet_hdr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga2498927473326e81b6eea5b6a9d33b6e">nfq_get_msg_packet_hdr</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:ga2498927473326e81b6eea5b6a9d33b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6f1bf4fcdc193b6ffe115471e97ffe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaaf6f1bf4fcdc193b6ffe115471e97ffe">nfq_get_nfmark</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:gaaf6f1bf4fcdc193b6ffe115471e97ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220fa4a4da71d4b84b5b05ef93c9e036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga220fa4a4da71d4b84b5b05ef93c9e036">nfq_get_timestamp</a> (struct nfq_data *nfad, struct timeval *tv)</td></tr>
<tr class="separator:ga220fa4a4da71d4b84b5b05ef93c9e036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14c4a30d6ade1f758d1764ba7a11be6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaf14c4a30d6ade1f758d1764ba7a11be6">nfq_get_indev</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:gaf14c4a30d6ade1f758d1764ba7a11be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97523c38735b1cb12ebc79da6a22da4d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga97523c38735b1cb12ebc79da6a22da4d">nfq_get_physindev</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:ga97523c38735b1cb12ebc79da6a22da4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b3bec8898ec7e2464fef059b00d231"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gae8b3bec8898ec7e2464fef059b00d231">nfq_get_outdev</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:gae8b3bec8898ec7e2464fef059b00d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c51ee31c2630caf1e83321c82896840"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga8c51ee31c2630caf1e83321c82896840">nfq_get_physoutdev</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:ga8c51ee31c2630caf1e83321c82896840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96976d032df823e8980dad5c8498ac2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gad96976d032df823e8980dad5c8498ac2">nfq_get_indev_name</a> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)</td></tr>
<tr class="separator:gad96976d032df823e8980dad5c8498ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0e1b8ce2ead9ae9b47dd774324a585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga5a0e1b8ce2ead9ae9b47dd774324a585">nfq_get_physindev_name</a> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)</td></tr>
<tr class="separator:ga5a0e1b8ce2ead9ae9b47dd774324a585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13708e5a6397e64137fb84e4b0cf1fb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga13708e5a6397e64137fb84e4b0cf1fb0">nfq_get_outdev_name</a> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)</td></tr>
<tr class="separator:ga13708e5a6397e64137fb84e4b0cf1fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f07e039c04b9a71ee25623328777dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga83f07e039c04b9a71ee25623328777dc">nfq_get_physoutdev_name</a> (struct nlif_handle *nlif_handle, struct nfq_data *nfad, char *name)</td></tr>
<tr class="separator:ga83f07e039c04b9a71ee25623328777dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db3aa65f17cca3ea07c50994524c160"><td class="memItemLeft" align="right" valign="top">struct nfqnl_msg_packet_hw *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga8db3aa65f17cca3ea07c50994524c160">nfq_get_packet_hw</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:ga8db3aa65f17cca3ea07c50994524c160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4b0a544e7cb2bb55e9bcf9e7d1ff3d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gacf4b0a544e7cb2bb55e9bcf9e7d1ff3d">nfq_get_skbinfo</a> (struct nfq_data *nfad)</td></tr>
<tr class="separator:gacf4b0a544e7cb2bb55e9bcf9e7d1ff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb4fca4236dfb337ff5781f5e8d1d2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaddb4fca4236dfb337ff5781f5e8d1d2e">nfq_get_uid</a> (struct nfq_data *nfad, uint32_t *uid)</td></tr>
<tr class="separator:gaddb4fca4236dfb337ff5781f5e8d1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaebd984aa1c97eb0a3a545b8194a1ff2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaaebd984aa1c97eb0a3a545b8194a1ff2">nfq_get_gid</a> (struct nfq_data *nfad, uint32_t *gid)</td></tr>
<tr class="separator:gaaebd984aa1c97eb0a3a545b8194a1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5803160a301b46b9955147f3565d6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga0b5803160a301b46b9955147f3565d6f">nfq_get_secctx</a> (struct nfq_data *nfad, unsigned char **secdata)</td></tr>
<tr class="separator:ga0b5803160a301b46b9955147f3565d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79628558c94630e25dbfcbde09f2933"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaf79628558c94630e25dbfcbde09f2933">nfq_get_payload</a> (struct nfq_data *nfad, unsigned char **data)</td></tr>
<tr class="separator:gaf79628558c94630e25dbfcbde09f2933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaaebd984aa1c97eb0a3a545b8194a1ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_gid </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_gid - get the GID of the user the packet belongs to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">gid</td><td>Set to GID on return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In this case, only one fragment will have the GID field set. To deal with this issue always set NFQA_CFG_F_GSO.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a GID available, 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01277">1277</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf14c4a30d6ade1f758d1764ba7a11be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_indev </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_indev - get the interface that the packet was received through </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the device the queued packet was received via. If the returned index is 0, the packet was locally generated or the input interface is not known (ie. POSTROUTING?).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>all nfq_get_dev() functions return 0 if not set, since linux only allows ifindex &gt;= 1, see net/core/dev.c:2600 (in 2.6.13.1) </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01028">1028</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad96976d032df823e8980dad5c8498ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_indev_name </td>
          <td>(</td>
          <td class="paramtype">struct nlif_handle *&#160;</td>
          <td class="paramname"><em>nlif_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_indev_name - get the name of the interface the packet was received through </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlif_handle</td><td>pointer to a nlif interface resolving handle </td></tr>
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">name</td><td>pointer to the buffer to receive the interface name; not more than <code>IFNAMSIZ</code> bytes will be copied to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 in case of error, &gt;0 if it succeed.</dd></dl>
<p>To use a nlif_handle, You need first to call nlif_open() and to open an handler. Don't forget to store the result as it will be used during all your program life: </p>
<pre class="fragment">        h = nlif_open();
        if (h == NULL) {
                perror("nlif_open");
                exit(EXIT_FAILURE);
        }
</pre><p> Once the handler is open, you need to fetch the interface table at a whole via a call to nlif_query. </p>
<pre class="fragment">        nlif_query(h);
</pre><p> libnfnetlink is able to update the interface mapping when a new interface appears. To do so, you need to call nlif_catch() on the handler after each interface related event. The simplest way to get and treat event is to run a select() or poll() against the nlif file descriptor. To get this file descriptor, you need to use nlif_fd: </p>
<pre class="fragment">        if_fd = nlif_fd(h);
</pre><p> Don't forget to close the handler when you don't need the feature anymore: </p>
<pre class="fragment">        nlif_close(h);
</pre> 
<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01116">1116</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2498927473326e81b6eea5b6a9d33b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nfqnl_msg_packet_hdr* nfq_get_msg_packet_hdr </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfqnl_msg_packet_hdr - return the metaheader that wraps the packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the netfilter queue netlink packet header for the given nfq_data argument. Typically, the nfq_data value is passed as the 3rd parameter to the callback function set by a call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>.</dd></dl>
<p>The nfqnl_msg_packet_hdr structure is defined in libnetfilter_queue.h as:</p>
<pre class="fragment">        struct nfqnl_msg_packet_hdr {
                uint32_t        packet_id;      // unique ID of packet in queue
                uint16_t        hw_protocol;    // hw protocol (network order)
                uint8_t         hook;           // netfilter hook
        } __attribute__ ((packed));
</pre> 
<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00974">974</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf6f1bf4fcdc193b6ffe115471e97ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_nfmark </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_nfmark - get the packet mark </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the netfilter mark currently assigned to the given queued packet. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00987">987</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae8b3bec8898ec7e2464fef059b00d231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_outdev </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_outdev - gets the interface that the packet will be routed out </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the device the queued packet will be sent out. If the returned index is 0, the packet is destined for localhost or the output interface is not yet known (ie. PREROUTING?). </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01056">1056</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga13708e5a6397e64137fb84e4b0cf1fb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_outdev_name </td>
          <td>(</td>
          <td class="paramtype">struct nlif_handle *&#160;</td>
          <td class="paramname"><em>nlif_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_outdev_name - get the name of the physical interface the packet will be sent to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlif_handle</td><td>pointer to a nlif interface resolving handle </td></tr>
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">name</td><td>pointer to the buffer to receive the interface name; not more than <code>IFNAMSIZ</code> bytes will be copied to it.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__Parsing.html#gad96976d032df823e8980dad5c8498ac2">nfq_get_indev_name()</a> documentation for nlif_handle usage.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 in case of error, &gt; 0 if it succeed. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01156">1156</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8db3aa65f17cca3ea07c50994524c160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nfqnl_msg_packet_hw* nfq_get_packet_hw </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_packet_hw</p>
<p>get hardware address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the hardware address associated with the given queued packet. For ethernet packets, the hardware address returned (if any) will be the MAC address of the packet source host. The destination MAC address is not known until after POSTROUTING and a successful ARP request, so cannot currently be retrieved.</p>
<p>The nfqnl_msg_packet_hw structure is defined in libnetfilter_queue.h as: </p>
<pre class="fragment">        struct nfqnl_msg_packet_hw {
                uint16_t        hw_addrlen;
                uint16_t        _pad;
                uint8_t hw_addr[8];
        } __attribute__ ((packed));
</pre> 
<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01207">1207</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf79628558c94630e25dbfcbde09f2933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_payload </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_payload - get payload </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">data</td><td>Pointer of pointer that will be pointed to the payload</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve the payload for a queued packet. The actual amount and type of data retrieved by this function will depend on the mode set with the <a class="el" href="group__Queue.html#ga7c8303bbdc2e1a6f5ac7aebc33cfcbae">nfq_set_mode()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, otherwise &gt; 0. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01324">1324</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga97523c38735b1cb12ebc79da6a22da4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_physindev </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_physindev - get the physical interface that the packet was received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the physical device the queued packet was received via. If the returned index is 0, the packet was locally generated or the physical input interface is no longer known (ie. POSTROUTING?). </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01042">1042</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a0e1b8ce2ead9ae9b47dd774324a585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_physindev_name </td>
          <td>(</td>
          <td class="paramtype">struct nlif_handle *&#160;</td>
          <td class="paramname"><em>nlif_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_physindev_name - get the name of the physical interface the packet was received through </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlif_handle</td><td>pointer to a nlif interface resolving handle </td></tr>
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">name</td><td>pointer to the buffer to receive the interface name; not more than <code>IFNAMSIZ</code> bytes will be copied to it.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__Parsing.html#gad96976d032df823e8980dad5c8498ac2">nfq_get_indev_name()</a> documentation for nlif_handle usage.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 in case of error, &gt; 0 if it succeed. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01136">1136</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c51ee31c2630caf1e83321c82896840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_physoutdev </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_physoutdev - get the physical interface that the packet output </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<p>The index of the physical device the queued packet will be sent out. If the returned index is 0, the packet is destined for localhost or the physical output interface is not yet known (ie. PREROUTING?).</p>
<dl class="section return"><dt>Returns</dt><dd>The index of physical interface that the packet output will be routed out. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01072">1072</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga83f07e039c04b9a71ee25623328777dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_physoutdev_name </td>
          <td>(</td>
          <td class="paramtype">struct nlif_handle *&#160;</td>
          <td class="paramname"><em>nlif_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_physoutdev_name - get the name of the interface the packet will be sent to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlif_handle</td><td>pointer to a nlif interface resolving handle </td></tr>
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">name</td><td>pointer to the buffer to receive the interface name; not more than <code>IFNAMSIZ</code> bytes will be copied to it.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__Parsing.html#gad96976d032df823e8980dad5c8498ac2">nfq_get_indev_name()</a> documentation for nlif_handle usage.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 in case of error, &gt; 0 if it succeed. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01177">1177</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b5803160a301b46b9955147f3565d6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_secctx </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>secdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_secctx - get the security context for this packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">secdata</td><td>data to write the security context to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In this case, only one fragment will have the SECCTX field set. To deal with this issue always set NFQA_CFG_F_GSO.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, otherwise &gt; 0 </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01298">1298</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacf4b0a544e7cb2bb55e9bcf9e7d1ff3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nfq_get_skbinfo </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_skbinfo - return the NFQA_SKB_INFO meta information </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<p>This can be used to obtain extra information about a packet by testing the returned integer for any of the following bit flags:</p>
<ul>
<li>NFQA_SKB_CSUMNOTREADY packet header checksums will be computed by hardware later on, i.e. tcp/ip checksums in the packet must not be validated, application should pretend they are correct.</li>
<li>NFQA_SKB_GSO packet is an aggregated super-packet. It exceeds device mtu and will be (re-)split on transmit by hardware.</li>
<li>NFQA_SKB_CSUM_NOTVERIFIED packet checksum was not yet verified by the kernel/hardware, for example because this is an incoming packet and the NIC does not perform checksum validation at hardware level.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the skbinfo value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><b><a class="el" href="group__Queue.html#gab8672409480a68edab269130ac6742c4">nfq_set_queue_flags</a></b>(3) </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01236">1236</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga220fa4a4da71d4b84b5b05ef93c9e036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_timestamp </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_timestamp - get the packet timestamp </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">tv</td><td>structure to fill with timestamp info</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the received timestamp when the given queued packet.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01002">1002</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaddb4fca4236dfb337ff5781f5e8d1d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_get_uid </td>
          <td>(</td>
          <td class="paramtype">struct nfq_data *&#160;</td>
          <td class="paramname"><em>nfad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_get_uid - get the UID of the user the packet belongs to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfad</td><td>Netlink packet data handle passed to callback function </td></tr>
    <tr><td class="paramname">uid</td><td>Set to UID on return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the NFQA_CFG_F_GSO flag is not set, then fragmented packets may be pushed into the queue. In this case, only one fragment will have the UID field set. To deal with this issue always set NFQA_CFG_F_GSO.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a UID available, 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l01256">1256</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 13 2021 11:39:26 for libnetfilter_queue by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>

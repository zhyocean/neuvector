<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libnetfilter_queue: Queue handling [DEPRECATED]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libnetfilter_queue
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue handling [DEPRECATED]</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga32703f66bfe86e5d0d6a348511628d45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga32703f66bfe86e5d0d6a348511628d45">nfq_fd</a> (struct nfq_handle *h)</td></tr>
<tr class="separator:ga32703f66bfe86e5d0d6a348511628d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f250ddd7568c2aefbd163b03e4e28b"><td class="memItemLeft" align="right" valign="top">struct nfq_q_handle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue</a> (struct nfq_handle *h, uint16_t num, nfq_callback *cb, void *data)</td></tr>
<tr class="separator:ga79f250ddd7568c2aefbd163b03e4e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a1461e9a36c95a03cb4476109f33bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga32a1461e9a36c95a03cb4476109f33bb">nfq_destroy_queue</a> (struct nfq_q_handle *qh)</td></tr>
<tr class="separator:ga32a1461e9a36c95a03cb4476109f33bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593b576017b7423646f49558a39f4ee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga593b576017b7423646f49558a39f4ee5">nfq_handle_packet</a> (struct nfq_handle *h, char *buf, int len)</td></tr>
<tr class="separator:ga593b576017b7423646f49558a39f4ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8303bbdc2e1a6f5ac7aebc33cfcbae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga7c8303bbdc2e1a6f5ac7aebc33cfcbae">nfq_set_mode</a> (struct nfq_q_handle *qh, uint8_t mode, uint32_t range)</td></tr>
<tr class="separator:ga7c8303bbdc2e1a6f5ac7aebc33cfcbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8672409480a68edab269130ac6742c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#gab8672409480a68edab269130ac6742c4">nfq_set_queue_flags</a> (struct nfq_q_handle *qh, uint32_t mask, uint32_t flags)</td></tr>
<tr class="separator:gab8672409480a68edab269130ac6742c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf8f92fc12226a2e494f9932e3853e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#gabdf8f92fc12226a2e494f9932e3853e4">nfq_set_queue_maxlen</a> (struct nfq_q_handle *qh, uint32_t queuelen)</td></tr>
<tr class="separator:gabdf8f92fc12226a2e494f9932e3853e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a82327d3f5a268168c4e71b275625b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga3a82327d3f5a268168c4e71b275625b5">nfq_set_verdict</a> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t data_len, const unsigned char *buf)</td></tr>
<tr class="separator:ga3a82327d3f5a268168c4e71b275625b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47f0abc93e8294a0cd758b86c36f90b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#gab47f0abc93e8294a0cd758b86c36f90b">nfq_set_verdict2</a> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark, uint32_t data_len, const unsigned char *buf)</td></tr>
<tr class="separator:gab47f0abc93e8294a0cd758b86c36f90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd74d0b452f7df58f39b1a59033f3e81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#gabd74d0b452f7df58f39b1a59033f3e81">nfq_set_verdict_batch</a> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict)</td></tr>
<tr class="separator:gabd74d0b452f7df58f39b1a59033f3e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176005fade2a156f52c6d80594473a5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#ga176005fade2a156f52c6d80594473a5b">nfq_set_verdict_batch2</a> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark)</td></tr>
<tr class="separator:ga176005fade2a156f52c6d80594473a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54f694b9f3fc6cf71761b6337852153"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Queue.html#gaf54f694b9f3fc6cf71761b6337852153">nfq_set_verdict_mark</a> (struct nfq_q_handle *qh, uint32_t id, uint32_t verdict, uint32_t mark, uint32_t data_len, const unsigned char *buf)</td></tr>
<tr class="separator:gaf54f694b9f3fc6cf71761b6337852153"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Once libnetfilter_queue library has been initialised (See <a class="el" href="group__LibrarySetup.html">LibrarySetup</a>), it is possible to bind the program to a specific queue. This can be done by using <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>.</p>
<p>The queue can then be tuned via <a class="el" href="group__Queue.html#ga7c8303bbdc2e1a6f5ac7aebc33cfcbae">nfq_set_mode()</a> or <a class="el" href="group__Queue.html#gabdf8f92fc12226a2e494f9932e3853e4">nfq_set_queue_maxlen()</a>.</p>
<p>Here's a little code snippet that create queue numbered 0: </p>
<pre class="fragment">        printf("binding this socket to queue '0'\n");
        qh = nfq_create_queue(h,  0, &amp;cb, NULL);
        if (!qh) {
                fprintf(stderr, "error during nfq_create_queue()\n");
                exit(1);
        }

        printf("setting copy_packet mode\n");
        if (nfq_set_mode(qh, NFQNL_COPY_PACKET, 0xffff) &lt; 0) {
                fprintf(stderr, "can't set packet_copy mode\n");
                exit(1);
        }
</pre><p>Next step is the handling of incoming packets which can be done via a loop:</p>
<pre class="fragment">        fd = nfq_fd(h);

        while ((rv = recv(fd, buf, sizeof(buf), 0)) &gt;= 0) {
                printf("pkt received\n");
                nfq_handle_packet(h, buf, rv);
        }
</pre><p> When the decision on a packet has been choosed, the verdict has to be given by calling <a class="el" href="group__Queue.html#ga3a82327d3f5a268168c4e71b275625b5">nfq_set_verdict()</a> or <a class="el" href="group__Queue.html#gab47f0abc93e8294a0cd758b86c36f90b">nfq_set_verdict2()</a>. The verdict determines the destiny of the packet as follows:</p>
<ul>
<li>NF_DROP discarded the packet</li>
<li>NF_ACCEPT the packet passes, continue iterations</li>
<li>NF_QUEUE inject the packet into a different queue (the target queue number is in the high 16 bits of the verdict)</li>
<li>NF_REPEAT iterate the same cycle once more</li>
<li>NF_STOP accept, but don't continue iterations</li>
</ul>
<p>The verdict NF_STOLEN must not be used, as it has special meaning in the kernel. When using NF_REPEAT, one way to prevent re-queueing of the same packet is to also set an nfmark using nfq_set_verdict2, and set up the nefilter rules to only queue a packet when the mark is not (yet) set.</p>
<p>Data and information about the packet can be fetch by using message parsing functions (See <a class="el" href="group__Parsing.html">Parsing</a>). </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga79f250ddd7568c2aefbd163b03e4e28b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nfq_q_handle* nfq_create_queue </td>
          <td>(</td>
          <td class="paramtype">struct nfq_handle *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nfq_callback *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_create_queue - create a new queue handle and return it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Netfilter queue connection handle obtained via call to <a class="el" href="group__LibrarySetup.html#ga6cf73d35946eae0e4fd8cfe9a1eccfd7">nfq_open()</a> </td></tr>
    <tr><td class="paramname">num</td><td>the number of the queue to bind to </td></tr>
    <tr><td class="paramname">cb</td><td>callback function to call for each queued packet </td></tr>
    <tr><td class="paramname">data</td><td>custom data to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nfq_q_handle pointing to the newly created queue</dd></dl>
<p>Creates a new queue handle, and returns it. The new queue is identified by <b>num</b>, and the callback specified by <b>cb</b> will be called for each enqueued packet. The <b>data</b> argument will be passed unchanged to the callback. If a queue entry with id <b>num</b> already exists, this function will return failure and the existing entry is unchanged.</p>
<p>The nfq_callback type is defined in libnetfilter_queue.h as: </p>
<pre class="fragment">typedef int nfq_callback(struct nfq_q_handle *qh,
                         struct nfgenmsg *nfmsg,
                         struct nfq_data *nfad, void *data);
</pre><p>Parameters:</p>
<ul>
<li>qh The queue handle returned by nfq_create_queue</li>
<li>nfmsg message objetc that contains the packet</li>
<li>nfad Netlink packet data handle</li>
<li>data the value passed to the data parameter of nfq_create_queue</li>
</ul>
<p>The callback should return &lt; 0 to stop processing. </p>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00538">538</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga32a1461e9a36c95a03cb4476109f33bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_destroy_queue </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_destroy_queue - destroy a queue handle </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>queue handle that we want to destroy created via nfq_create_queue</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the binding for the specified queue handle. This call also unbind from the nfqueue handler, so you don't have to call nfq_unbind_pf. </p>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00585">585</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga32703f66bfe86e5d0d6a348511628d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_fd </td>
          <td>(</td>
          <td class="paramtype">struct nfq_handle *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_fd - get the file descriptor associated with the nfqueue handler </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Netfilter queue connection handle obtained via call to <a class="el" href="group__LibrarySetup.html#ga6cf73d35946eae0e4fd8cfe9a1eccfd7">nfq_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file descriptor for the netlink connection associated with the given queue connection handle. The file descriptor can then be used for receiving the queued packets for processing.</dd></dl>
<p>This function returns a file descriptor that can be used for communication over the netlink connection associated with the given queue connection handle. </p>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00308">308</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga593b576017b7423646f49558a39f4ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_handle_packet </td>
          <td>(</td>
          <td class="paramtype">struct nfq_handle *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_handle_packet - handle a packet received from the nfqueue subsystem </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Netfilter queue connection handle obtained via call to <a class="el" href="group__LibrarySetup.html#ga6cf73d35946eae0e4fd8cfe9a1eccfd7">nfq_open()</a> </td></tr>
    <tr><td class="paramname">buf</td><td>data to pass to the callback </td></tr>
    <tr><td class="paramname">len</td><td>length of packet data in buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Triggers an associated callback for the given packet received from the queue. Packets can be read from the queue using <a class="el" href="group__Queue.html#ga32703f66bfe86e5d0d6a348511628d45">nfq_fd()</a> and recv(). See example code for <a class="el" href="group__Queue.html#ga32703f66bfe86e5d0d6a348511628d45">nfq_fd()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00609">609</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c8303bbdc2e1a6f5ac7aebc33cfcbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_mode - set the amount of packet data that nfqueue copies to userspace </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">mode</td><td>the part of the packet that we are interested in </td></tr>
    <tr><td class="paramname">range</td><td>size of the packet that we want to get</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the amount of data to be copied to userspace for each packet queued to the given queue.</p>
<ul>
<li>NFQNL_COPY_NONE - noop, do not use it</li>
<li>NFQNL_COPY_META - copy only packet metadata</li>
<li>NFQNL_COPY_PACKET - copy entire packet</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>-1 on error; &gt;=0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00630">630</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab8672409480a68edab269130ac6742c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_queue_flags </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_queue_flags - set flags (options) for the kernel queue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">mask</td><td>specifies which flag bits to modify </td></tr>
    <tr><td class="paramname">flags</td><td>bitmask of flags</td></tr>
  </table>
  </dd>
</dl>
<p>Existing flags, that you may want to combine, are:</p>
<ul>
<li>NFQA_CFG_F_FAIL_OPEN (requires Linux kernel &gt;= 3.6): the kernel will accept the packets if the kernel queue gets full. If this flag is not set, the default action in this case is to drop packets.</li>
<li>NFQA_CFG_F_CONNTRACK (requires Linux kernel &gt;= 3.6): the kernel will include the Connection Tracking system information.</li>
<li><p class="startli">NFQA_CFG_F_GSO (requires Linux kernel &gt;= 3.10): the kernel will not normalize offload packets, i.e. your application will need to be able to handle packets larger than the mtu.</p>
<p class="startli">Normalization is expensive, so this flag should always be set. Because attributes in netlink messages are limited to 65531 bytes, you also need to check the NFQA_CAP_LEN attribute, it contains the original size of the captured packet on the kernel side. If it is set and differs from the payload length, the packet was truncated. This also happens when limiting capture size with the NFQNL_COPY_PACKET setting, or when e.g. a local user sends a very large packet.</p>
<p class="startli">If your application validates checksums (e.g., tcp checksum), then you must also check if the NFQA_SKB_INFO attribute is present. If it is, you need to test the NFQA_SKB_CSUMNOTREADY bit: </p>
<pre class="fragment">        if (attr[NFQA_SKB_INFO]) {
                uint32_t info = ntohl(mnl_attr_get_u32(attr[NFQA_SKB_INFO]));
                if (info &amp; NFQA_SKB_CSUMNOTREADY)
                        validate_checksums = false;
        }
</pre><p> if this bit is set, the layer 3/4 checksums of the packet appear incorrect, but are not (because they will be corrected later by the kernel). Please see example/nf-queue.c in the libnetfilter_queue source for more details.</p>
<ul>
<li>NFQA_CFG_F_UID_GID: the kernel will dump UID and GID of the socket to which each packet belongs.</li>
</ul>
</li>
</ul>
<p>Here's a little code snippet to show how to use this API: </p>
<pre class="fragment">        uint32_t flags = NFQA_CFG_F_FAIL_OPEN;
        uint32_t mask = NFQA_CFG_F_FAIL_OPEN;

        printf("Enabling fail-open on this q\n");
        err = nfq_set_queue_flags(qh, mask, flags);

        printf("Disabling fail-open on this q\n");
        flags &amp;= ~NFQA_CFG_F_FAIL_OPEN;
        err = nfq_set_queue_flags(qh, mask, flags);
</pre><ul>
<li>NFQA_CFG_F_SECCTX: the kernel will dump security context of the socket to which each packet belongs.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>When fragmentation occurs and NFQA_CFG_F_GSO is NOT set then the kernel dumps UID/GID and security context fields only for one fragment. To deal with this limitation always set NFQA_CFG_F_GSO.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error with errno set appropriately; =0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00719">719</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabdf8f92fc12226a2e494f9932e3853e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_queue_maxlen </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queuelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_queue_maxlen - Set kernel queue maximum length parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">queuelen</td><td>the length of the queue</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the size of the queue in kernel. This fixes the maximum number of packets the kernel will store before internally before dropping upcoming packets.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 on error; &gt;=0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00752">752</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a82327d3f5a268168c4e71b275625b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_verdict </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_verdict - issue a verdict on a packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">id</td><td>ID assigned to packet by netfilter. </td></tr>
    <tr><td class="paramname">verdict</td><td>verdict to return to netfilter (NF_ACCEPT, NF_DROP) </td></tr>
    <tr><td class="paramname">data_len</td><td>number of bytes of data pointed to by <b>buf</b> </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer that contains the packet data</td></tr>
  </table>
  </dd>
</dl>
<p>Can be obtained by: </p>
<pre class="fragment">        int id;
        struct nfqnl_msg_packet_hdr *ph = nfq_get_msg_packet_hdr(tb);
        if (ph)
                id = ntohl(ph-&gt;packet_id);
</pre><p>Notifies netfilter of the userspace verdict for the given packet. Every queued packet <em>must</em> have a verdict specified by userspace, either by calling this function, the <a class="el" href="group__Queue.html#gab47f0abc93e8294a0cd758b86c36f90b">nfq_set_verdict2()</a> function, or the _batch versions of these functions.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 on error; &gt;= 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00856">856</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab47f0abc93e8294a0cd758b86c36f90b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_verdict2 </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_verdict2 - like nfq_set_verdict, but you can set the mark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">id</td><td>ID assigned to packet by netfilter. </td></tr>
    <tr><td class="paramname">verdict</td><td>verdict to return to netfilter (NF_ACCEPT, NF_DROP) </td></tr>
    <tr><td class="paramname">mark</td><td>mark to put on packet </td></tr>
    <tr><td class="paramname">data_len</td><td>number of bytes of data pointed to by <b>buf</b> </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer that contains the packet data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00874">874</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabd74d0b452f7df58f39b1a59033f3e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_verdict_batch </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_verdict_batch - issue verdicts on several packets at once </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">id</td><td>maximum ID of the packets that the verdict should be applied to. </td></tr>
    <tr><td class="paramname">verdict</td><td>verdict to return to netfilter (NF_ACCEPT, NF_DROP)</td></tr>
  </table>
  </dd>
</dl>
<p>Unlike nfq_set_verdict, the verdict is applied to all queued packets whose packet id is smaller or equal to <b>id</b>.</p>
<p>batch support was added in Linux 3.1. These functions will fail silently on older kernels. </p>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00895">895</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga176005fade2a156f52c6d80594473a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_verdict_batch2 </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_verdict_batch2 - like nfq_set_verdict_batch, but you can set a mark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">id</td><td>maximum ID of the packets that the verdict should be applied to. </td></tr>
    <tr><td class="paramname">verdict</td><td>verdict to return to netfilter (NF_ACCEPT, NF_DROP) </td></tr>
    <tr><td class="paramname">mark</td><td>mark to put on packet </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00910">910</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf54f694b9f3fc6cf71761b6337852153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfq_set_verdict_mark </td>
          <td>(</td>
          <td class="paramtype">struct nfq_q_handle *&#160;</td>
          <td class="paramname"><em>qh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nfq_set_verdict_mark - like nfq_set_verdict, but you can set the mark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qh</td><td>Netfilter queue handle obtained by call to <a class="el" href="group__Queue.html#ga79f250ddd7568c2aefbd163b03e4e28b">nfq_create_queue()</a>. </td></tr>
    <tr><td class="paramname">id</td><td>ID assigned to packet by netfilter. </td></tr>
    <tr><td class="paramname">verdict</td><td>verdict to return to netfilter (NF_ACCEPT, NF_DROP) </td></tr>
    <tr><td class="paramname">mark</td><td>the mark to put on the packet, in network byte order. </td></tr>
    <tr><td class="paramname">data_len</td><td>number of bytes of data pointed to by <b>buf</b> </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer that contains the packet data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error; &gt;= 0 otherwise.</dd></dl>
<p>This function is deprecated since it is broken, its use is highly discouraged. Please, use nfq_set_verdict2 instead. </p>

<p>Definition at line <a class="el" href="libnetfilter__queue_8c_source.html#l00932">932</a> of file <a class="el" href="libnetfilter__queue_8c_source.html">libnetfilter_queue.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 13 2021 11:39:26 for libnetfilter_queue by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
